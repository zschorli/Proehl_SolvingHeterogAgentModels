% This is code for the working paper "Approximating Equilibria with Ex-Post 
% Heterogeneity and Aggregate Risk" by Elisabeth Pröhl
%
% AUTHOR Elisabeth Pröhl, University of Amsterdam
% DATE May 2025
%
% DESCRIPTION
% This function computes elements for the computation of the Jacobian to
% find the minimizer in the proximal point algorithm.
%__________________________________________________________________________
function [agK_prime_new_dk,c_pr_der] ...
         = calcJacobianProxies(k_prime,grid,StaticParams,Sol,Poly)
    h=1e-6;    
    k_prime_large = interp1(StaticParams.kGrid_pol,k_prime',StaticParams.kGrid)';   
    [~,weights_new] = calcAggregates(k_prime_large,grid,StaticParams,Poly);
    [agK_prime_new_dk,weights_new_dk] = calcAggregatesDer(k_prime_large,grid,StaticParams,Poly,h);
    c_prime = @(z_idx,z,k,w)...
               interp1(StaticParams.kGrid_pol,...
               getCApprox(Sol.grid_N,Sol.distrGrid,squeeze(Sol.c(:,2*z(1)+z(2)+1,:)),...
               Sol.idx,squeeze(w((z_idx>2)+1,z(1)+1,:))'),...
               max(StaticParams.k_min,k),'linear','extrap');
    c_pr_der = zeros([4,size(k_prime)]);
    for z_idx=1:4
        c_pr_der(z_idx,:,:) = [(c_prime(z_idx,[0,0],k_prime(z_idx,:)+h,weights_new)-c_prime(z_idx,[0,0],k_prime(z_idx,:)-h,weights_new))./(2*h);...
                               (c_prime(z_idx,[0,1],k_prime(z_idx,:)+h,weights_new)-c_prime(z_idx,[0,1],k_prime(z_idx,:)-h,weights_new))./(2*h);...
                               (c_prime(z_idx,[1,0],k_prime(z_idx,:)+h,weights_new)-c_prime(z_idx,[1,0],k_prime(z_idx,:)-h,weights_new))./(2*h);...
                               (c_prime(z_idx,[1,1],k_prime(z_idx,:)+h,weights_new)-c_prime(z_idx,[1,1],k_prime(z_idx,:)-h,weights_new))./(2*h)]...
                             +c_prime_derw(z_idx,k_prime(z_idx,:),weights_new,weights_new_dk,h,StaticParams,Sol,Poly);
    end  
end

function cpr_der = c_prime_derw(z_idx,k,w,weights_new_dk,h,StaticParams,Sol,Poly)
cpr_der = zeros(4,length(k));
c_prime = @(z_idx,z,k,w)...
               interp1(StaticParams.kGrid_pol,...
               getCApprox(Sol.grid_N,Sol.distrGrid,squeeze(Sol.c(:,2*z(1)+z(2)+1,:)),...
               Sol.idx,squeeze(w((z_idx>2)+1,z(1)+1,:))'),...
               max(StaticParams.k_min,k),'linear','extrap');
diff_w = @(idx) repmat(permute([zeros(1,idx-1),h,zeros(1,Poly.phi_N+1-idx)],[3,1,2]),[2,2,1]);    
for i=1:Poly.phi_N+1
    cpr_der = cpr_der + ...
        [(c_prime(z_idx,[0,0],k,w+diff_w(i))-c_prime(z_idx,[0,0],k,w-diff_w(i)))./(2*h).*squeeze(weights_new_dk(2-mod(z_idx,2),(z_idx>2)+1,1,i,:))';...
         (c_prime(z_idx,[0,1],k,w+diff_w(i))-c_prime(z_idx,[0,1],k,w-diff_w(i)))./(2*h).*squeeze(weights_new_dk(2-mod(z_idx,2),(z_idx>2)+1,1,i,:))';...
         (c_prime(z_idx,[1,0],k,w+diff_w(i))-c_prime(z_idx,[1,0],k,w-diff_w(i)))./(2*h).*squeeze(weights_new_dk(2-mod(z_idx,2),(z_idx>2)+1,2,i,:))';...
         (c_prime(z_idx,[1,1],k,w+diff_w(i))-c_prime(z_idx,[1,1],k,w-diff_w(i)))./(2*h).*squeeze(weights_new_dk(2-mod(z_idx,2),(z_idx>2)+1,2,i,:))'];
end
end