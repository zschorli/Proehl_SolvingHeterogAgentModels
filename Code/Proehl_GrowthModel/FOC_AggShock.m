% This is code for the working paper "Approximating Equilibria with Ex-Post 
% Heterogeneity and Aggregate Risk" by Elisabeth Pröhl
%
% AUTHOR Elisabeth Pröhl, University of Amsterdam
% DATE May 2025
%
% DESCRIPTION
% This function computes the first-order conditions to solve for in the
% proximal point algorithm with aggregate shocks.
%__________________________________________________________________________
function [f,J] = FOC_AggShock(sol,k_prime,y,agK_m,grid,m,StaticParams,Sol,Poly,agK_prime_new_dk,c_pr_der)

sol_k = reshape(sol,size(k_prime'))';

sol_k_large = interp1(StaticParams.kGrid_pol,sol_k',StaticParams.kGrid)';   
[agK_prime_new,weights_new] = calcAggregates(sol_k_large,grid,StaticParams,Poly);

rate_prime = [repmat(StaticParams.rate(0,agK_prime_new(1)),[1,numel(StaticParams.kGrid_pol)]);...
              repmat(StaticParams.rate(1,agK_prime_new(2)),[1,numel(StaticParams.kGrid_pol)])];
rate_prime_der = (StaticParams.alpha-1).*rate_prime...
                 ./repmat(agK_prime_new([1;1;2;2]),[1,numel(StaticParams.kGrid_pol)]);
ret = 1-StaticParams.delta+rate_prime;

c_prime = @(z_idx,z,k,w)...
           interp1(StaticParams.kGrid_pol,...
           getCApprox(Sol.grid_N,Sol.distrGrid,squeeze(Sol.c(:,2*z(1)+z(2)+1,:)),...
           Sol.idx,squeeze(w((z_idx>2)+1,z(1)+1,:))'),...
           max(StaticParams.k_min,k),'linear','extrap');
c_pr = zeros([4,size(k_prime,1),size(k_prime,2)]);
for z_idx=1:4
    c_pr(z_idx,:,:) = [c_prime(z_idx,[0,0],sol_k(z_idx,:),weights_new);...
                       c_prime(z_idx,[0,1],sol_k(z_idx,:),weights_new);...
                       c_prime(z_idx,[1,0],sol_k(z_idx,:),weights_new);...
                       c_prime(z_idx,[1,1],sol_k(z_idx,:),weights_new)] ;
end   

MargUt = @(c) c.^(-StaticParams.gamma);
MargUt_inv = @(c) c.^(-1./StaticParams.gamma);
MargUt_der = @(c) (-StaticParams.gamma).*c.^(-StaticParams.gamma-1);
MargUt_inv_der = @(c) (-1./StaticParams.gamma).*c.^(-1./StaticParams.gamma-1);

foc_k = -(squeeze(Sol.wealth(agK_m,:,:))-sol_k)...
          +MargUt_inv(StaticParams.beta.*ret.*...
           [StaticParams.P(1,:)*MargUt(squeeze(c_pr(1,:,:)));...
            StaticParams.P(2,:)*MargUt(squeeze(c_pr(2,:,:)));...
            StaticParams.P(3,:)*MargUt(squeeze(c_pr(3,:,:)));...
            StaticParams.P(4,:)*MargUt(squeeze(c_pr(4,:,:)))])...
          +1./m.*(sol_k-k_prime)...
          +(sol_k<=y./m).*(-y-m.*sol_k)+(sol_k>y./m).*(-1./m.*y);   

% function value of the Euler equation
f = reshape(foc_k',[],1);

% Jacobian of the Euler equation
if nargout>1    
    foc_k_dk_term1 = +MargUt_inv_der(StaticParams.beta.*ret.*...
               [StaticParams.P(1,:)*MargUt(squeeze(c_pr(1,:,:)));...
                StaticParams.P(2,:)*MargUt(squeeze(c_pr(2,:,:)));...
                StaticParams.P(3,:)*MargUt(squeeze(c_pr(3,:,:)));...
                StaticParams.P(4,:)*MargUt(squeeze(c_pr(4,:,:)))])...
              .*(StaticParams.beta.*rate_prime_der.*...
               [StaticParams.P(1,:)*squeeze(MargUt(c_pr(1,:,:)).*repmat(agK_prime_new_dk(1,1,:),[1,4,1]));...
                StaticParams.P(2,:)*squeeze(MargUt(c_pr(2,:,:)).*repmat(agK_prime_new_dk(2,1,:),[1,4,1]));...
                StaticParams.P(3,:)*squeeze(MargUt(c_pr(3,:,:)).*repmat(agK_prime_new_dk(1,2,:),[1,4,1]));...
                StaticParams.P(4,:)*squeeze(MargUt(c_pr(4,:,:)).*repmat(agK_prime_new_dk(2,2,:),[1,4,1]))]);
    foc_k_dk_term2 = +1 ...
              +MargUt_inv_der(StaticParams.beta.*ret.*...
               [StaticParams.P(1,:)*MargUt(squeeze(c_pr(1,:,:)));...
                StaticParams.P(2,:)*MargUt(squeeze(c_pr(2,:,:)));...
                StaticParams.P(3,:)*MargUt(squeeze(c_pr(3,:,:)));...
                StaticParams.P(4,:)*MargUt(squeeze(c_pr(4,:,:)))])...
               .*(StaticParams.beta.*ret.*...
               [StaticParams.P(1,:)*squeeze(MargUt_der(c_pr(1,:,:)).*c_pr_der(1,:,:));...
                StaticParams.P(2,:)*squeeze(MargUt_der(c_pr(2,:,:)).*c_pr_der(2,:,:));...
                StaticParams.P(3,:)*squeeze(MargUt_der(c_pr(3,:,:)).*c_pr_der(3,:,:));...
                StaticParams.P(4,:)*squeeze(MargUt_der(c_pr(4,:,:)).*c_pr_der(4,:,:))])...
              +1./m+(sol_k<=y./m).*(-m);
    foc_k_dk = foc_k_dk_term1+foc_k_dk_term2;   
    
    J = sparse(1:length(sol),1:length(sol),reshape(foc_k_dk',[],1));
end
end